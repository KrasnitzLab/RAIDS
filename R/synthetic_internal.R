#' @title Validate input parameters for syntheticGeno() function
#'
#' @description This function validates the input parameters for the
#' \code{\link{syntheticGeno}} function.
#'
#' @param gds an object of class \code{\link[gdsfmt]{gds.class}}
#' (a GDS file), the 1KG GDS file.
#'
#' @param gdsRefAnnot an object of class \code{\link[gdsfmt]{gds.class}}
#' (a GDS file), the1 1KG SNV Annotation GDS file.
#'
#' @param gdsSampleFile a \code{character} string representing the file name of
#' the GDS Sample file containing the information about the sample.
#' The file must exist.
#'
#' @param listSampleRef a \code{vector} of \code{character} strings
#' representing the sample identifiers of the 1KG selected reference samples.
#'
#' @param data.id.profile a \code{character} string representing the unique
#' identifier of the cancer sample.
#'
#' @param nbSim a single positive \code{integer} representing the number of
#' simulations that will be generated per sample + 1KG reference combination.
#'
#' @param prefId a \code{character} string that represent the prefix that will
#' be added to the name of the synthetic profiles generated by the function.
#'
#' @param pRecomb a single positive \code{numeric} between 0 and 1 that
#' represents the frequency of phase switching in the synthetic profiles.
#'
#' @param minProb a single positive \code{numeric} between 0 and 1 that
#' represents the probability that the genotype is correct.
#'
#' @param seqError a single positive \code{numeric} between 0 and 1
#' representing the sequencing error rate.
#'
#' @return The integer \code{0L} when the function is successful.
#'
#' @examples
#'
#' ## Directory where demo GDS files are located
#' data.dir <- system.file("extdata", package="RAIDS")
#'
#' ## The 1KG GDS file (opened)
#' gds1KG <- openfn.gds(file.path(data.dir, "gds1KG.gds"), readonly=TRUE)
#'
#' ## The 1KG GDS Annotation file (opened)
#' gds1KGAnnot <- openfn.gds(file.path(data.dir, "gdsAnnot1KG.gds"),
#'                              readonly=TRUE)
#'
#' ## The GDS Sample file
#' gdsSample <- file.path(data.dir, "GDS_Sample_with_study_demo.gds")
#'
#' ## The validation should be successful
#' RAIDS:::validateSyntheticGeno(gds=gds1KG, gdsRefAnnot=gds1KGAnnot,
#'      gdsSampleFile=gdsSample, data.id.profile="A101TCGA",
#'      listSampleRef="A101TCGA", nbSim=1L, prefId="TCGA", pRecomb=0.02,
#'      minProb=0.999, seqError=0.002)
#'
#' ## All GDS file must be closed
#' closefn.gds(gdsfile=gds1KG)
#' closefn.gds(gdsfile=gds1KGAnnot)
#'
#' @author Pascal Belleau, Astrid Deschênes and Alexander Krasnitz
#' @importFrom S4Vectors isSingleNumber
#' @encoding UTF-8
#' @keywords internal
validateSyntheticGeno <- function(gds, gdsRefAnnot, gdsSampleFile,
                                        data.id.profile,
                                        listSampleRef,
                                        nbSim,
                                        prefId,
                                        pRecomb,
                                        minProb,
                                        seqError) {

    ## The gds must be an object of class "gds.class"
    if (!inherits(gds, "gds.class")) {
        stop("The \'gds\' must be an object of class \'gds.class\'.")
    }

    ## The gdsRefAnnot must be an object of class "gds.class"
    if (!inherits(gdsRefAnnot, "gds.class")) {
        stop("The \'gdsRefAnnot\' must be an object of class \'gds.class\'.")
    }

    ## The gdsSampleFile must be an character string and the file must exist
    if (!(is.character(gdsSampleFile) && file.exists(gdsSampleFile))) {
        stop("The \'gdsSampleFile\' must be a character string and the file ",
                "must exist.")
    }

    ## The data.id.profile must be a character string
    if (!(is.character(data.id.profile) && length(data.id.profile) == 1)) {
        stop("The \'data.id.profile\' must be a character string.")
    }

    ## The listSampleRef must be a character string
    if(!is.character(listSampleRef)) {
        stop("The \'listSampleRef\' must be a vector of character strings.")
    }

    ## The parameter nbSim must be a single positive integer
    if(!(isSingleNumber(nbSim) && (nbSim >= 0))) {
        stop("The \'nbSim\' parameter must be a single positive ",
                "numeric value.")
    }

    ## The parameter prefId must be a single character string
    if(!(is.character(prefId) && (length(prefId) == 1))) {
        stop("The \'prefId\' parameter must be a single character ",
                "string.")
    }

    ## The parameter pRecomb must be a single positive integer
    if(!(isSingleNumber(pRecomb) && (pRecomb >= 0.0) && (pRecomb <= 1.0))) {
        stop("The \'pRecomb\' parameter must be a single positive ",
                "numeric value between 0 and 1.")
    }

    ## The parameter minProb must be a single positive integer
    if(!(isSingleNumber(minProb) && (minProb >= 0.0) && (minProb <= 1.0))) {
        stop("The \'minProb\' parameter must be a single positive ",
                "numeric value between 0 and 1.")
    }

    ## The parameter seqError must be a single positive integer
    if(!(isSingleNumber(seqError) && (seqError >= 0.0) && (seqError <= 1.0))) {
        stop("The \'seqError\' parameter must be a single positive ",
                "numeric value between 0 and 1.")
    }

    return(0L)
}


#' @title Extract the sample information from the 1KG GDS file for a list
#' of profiles associated to a specific study in the GDS Sample file
#'
#' @description The function extracts the information for the profiles
#' associated to a specific study in the GDS Sample file. The information is
#' extracted from the 'study.annot' node as a 'data.frame'.
#'
#' Then, the function used the 1KG GDS file to extract specific information
#' about each sample and add it, as an extra column, to the 'data.frame'.
#'
#' As example, this function can extract the synthetic profiles
#' for a GDS Sample and the super-population of the 1KG samples used to
#' generate each synthetic profile would be added
#' as an extra column to the final 'data.frame'.
#'
#' @param gds an object of class
#' \code{\link[gdsfmt:gds.class]{gdsfmt::gds.class}}, the opened 1 KG GDS file.
#'
#' @param gdsSample an object of class
#' \code{\link[gdsfmt:gds.class]{gdsfmt::gds.class}}, the opened GDS Sample
#' file.
#'
#' @param study.id a \code{character} string representing the name of the
#' study that will be extracted from the GDS Sample 'study.annot' node.
#'
#' @param popName a \code{character} string representing the name of the
#' column from the \code{data.frame} stored in the 'sample.annot' node of the
#' 1KG GDS file. The column must be present in the \code{data.frame}.
#'
#'
#' @return \code{data.frame} containing the columns extracted from the
#' GDS Sample 'study.annot' node with a extra column named as the 'popName'
#' parameter that has been extracted from the 1KG GDS 'sample.annot' node.
#' Only the rows corresponding to the specified study ('study.id' parameter)
#' are returned.
#'
#'
#' @details
#'
#' As example, this function can extract the synthetic profiles
#' for a GDS Sample and the super-population of the 1KG samples used to
#' generate each synthetic profile would be added
#' as an extra column to the final 'data.frame'. In that situation, the
#' 'popName' parameter would correspond to the super-population column and the
#' 'study.id' parameter would be the name given to the synthetic dataset.
#'
#'
#' @examples
#'
#' ## The open 1KG GDS file is required (this is a demo file)
#' data.dir <- system.file("extdata", package="RAIDS")
#' gds_1KG_file <- file.path(data.dir, "1KG_Demo.gds")
#' gds1KG <- openfn.gds(gds_1KG_file)
#'
#' gds_sample_file <- file.path(data.dir, "GDS_Sample_with_study_demo.gds")
#' gdsSample <- openfn.gds(gds_sample_file)
#'
#' ## Extract the study information for "TCGA.Synthetic" study present in the
#' ## GDS Sample file and merge column "superPop" from 1KG GDS to the
#' ## returned data.frame
#' ## This function enables to extract the super-population associated to the
#' ## 1KG samples that has been used to create the synthetic profiles
#' RAIDS:::prepPedSynthetic1KG(gds=gds1KG, gdsSample=gdsSample,
#'     study.id="TCGA.Synthetic", popName="superPop")
#'
#' ## The GDS files must be closed
#' gdsfmt::closefn.gds(gds1KG)
#' gdsfmt::closefn.gds(gdsSample)
#'
#'
#' @author Pascal Belleau, Astrid Deschênes and Alexander Krasnitz
#' @importFrom gdsfmt index.gdsn read.gdsn
#' @encoding UTF-8
#' @keywords internal
prepPedSynthetic1KG <- function(gds, gdsSample, study.id, popName) {

    ## Extract study information from the GDS Sample file
    study.annot <- read.gdsn(index.gdsn(gdsSample, "study.annot"))

    ## Retain the information associated to the current study
    studyCur <- study.annot[which(study.annot$study.id == study.id),]
    rm(study.annot)

    ## Get the information from 1KG GDS file
    dataRef <- read.gdsn(index.gdsn(node=gds, "sample.annot"))

    if(! popName %in% colnames(dataRef)) {
        stop("The population ", popName, " is not supported.")
    }

    ## Assign sample names to the information
    row.names(dataRef) <- read.gdsn(index.gdsn(node=gds, "sample.id"))

    studyCur[[popName]] <- dataRef[studyCur$case.id, popName]
    rownames(studyCur) <- studyCur$data.id

    return(studyCur)
}


#' @title TODO
#'
#' @description TODO
#'
#' @param matKNN TODO
#'
#' @param pedCall TODO see return of prepPedSynthetic1KG
#'
#' @param refCall TODO column name in pedCall with the call
#'
#' @param predCall a \code{character} string representing the name of
#' the column that will contain the inferred ancestry for the specified
#' dataset.
#'
#' @param listCall TODO array of the possible call
#'
#' @return \code{list} containing 2 entries:
#' \itemize{
#' \item{confMat} { TODO }
#' \item{matAccuracy} { a \code{data.frame} TODO}
#' }
#'
#' @examples
#'
#' ## TODO
#' gds <- "TODO"
#'
#' @author Pascal Belleau, Astrid Deschênes and Alex Krasnitz
#' @encoding UTF-8
#' @keywords internal
computeSyntheticConfMat <- function(matKNN, pedCall, refCall, predCall,
                                            listCall) {

    matAccuracy <- data.frame(pcaD=matKNN$D[1], K=matKNN$K[1],
                        Accu.CM=numeric(1), CM.CI=numeric(1), N=nrow(matKNN),
                        NBNA=length(which(is.na(matKNN[[predCall]]))))
    i <- 1
    if(length(unique(matKNN$D)) != 1 | length(unique(matKNN$K)) != 1){
        stop("Compute synthetic accuracy with different pca dimension or K\n")
    }

    #matCur <- matKNN[which(matKNN$D == pcaD & matKNN$K == k),]
    listKeep <- which(!(is.na(matKNN[[predCall]])) )

    fCall <- factor(pedCall[matKNN$sample.id[listKeep], refCall],
                            levels=listCall, labels=listCall)

    fP <- factor(matKNN[[predCall]][listKeep],
                            levels = listCall, labels = listCall)

    cm <- table(fCall, fP)


    matAccuracy[i, 3] <- sum(diag(cm[rownames(cm) %in% listCall,
                                        colnames(cm) %in% listCall])) /
        nrow(pedCall[matKNN$sample.id, ][listKeep,])

    matAccuracy[i, 4] <- 1.96 * (matAccuracy[i, 3] * (1 - matAccuracy[i, 3]) /
                            nrow(pedCall[matKNN$sample.id, ][listKeep,]))^0.5

    ## Generate list that will be returned
    res <- list(confMat=cm, matAccuracy=matAccuracy)

    return(res)
}
